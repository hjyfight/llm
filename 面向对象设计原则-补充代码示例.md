# 面向对象七大设计原则 - 补充代码示例

## 实际项目中的重构案例

### 案例1：重构前的违反单一职责原则

```python
# 原始代码 - 违反单一职责原则
class SentimentHandler:
    def __init__(self):
        self.db = SessionLocal()
        self.llm_client = SiliconFlowClient()
    
    def process_request(self, text: str, user_id: str):
        # 1. 数据验证
        if not text or len(text) > 1000:
            return {"error": "文本无效"}
        
        # 2. 调用LLM分析
        analysis = self.llm_client.analyze(text)
        
        # 3. 数据库保存
        record = SentimentRecord(
            user_id=user_id,
            text=text,
            sentiment=analysis["sentiment"],
            confidence=analysis["confidence"]
        )
        self.db.add(record)
        self.db.commit()
        
        # 4. 返回结果
        return {"id": record.id, "analysis": analysis}
```

### 案例2：重构后遵循单一职责原则

```python
# 数据验证器
class SentimentValidator:
    @staticmethod
    def validate_text(text: str) -> bool:
        return text and 0 < len(text) <= 1000

# 数据访问层
class SentimentRepository:
    def __init__(self, db_session: Session):
        self.db = db_session
    
    def save_record(self, record_data: dict) -> SentimentRecord:
        record = SentimentRecord(**record_data)
        self.db.add(record)
        self.db.commit()
        self.db.refresh(record)
        return record

# LLM服务层
class SentimentAnalysisService:
    def __init__(self, llm_client):
        self.llm_client = llm_client
    
    def analyze_text(self, text: str) -> dict:
        return self.llm_client.analyze(text)

# 控制器层 - 只负责协调
class SentimentController:
    def __init__(self, validator, repository, analysis_service):
        self.validator = validator
        self.repository = repository
        self.analysis_service = analysis_service
    
    def process_request(self, text: str, user_id: str) -> dict:
        # 委托给专门的验证器
        if not self.validator.validate_text(text):
            return {"error": "文本无效"}
        
        # 委托给专门的分析服务
        analysis = self.analysis_service.analyze_text(text)
        
        # 委托给专门的数据访问层
        record_data = {
            "user_id": user_id,
            "text": text,
            "sentiment": analysis["sentiment"],
            "confidence": analysis["confidence"]
        }
        record = self.repository.save_record(record_data)
        
        return {"id": record.id, "analysis": analysis}
```

## 案例3：开闭原则的实际应用

```python
# 扩展点定义
class SentimentProcessor(ABC):
    @abstractmethod
    def process(self, text: str) -> dict:
        pass

class Preprocessor(ABC):
    @abstractmethod
    def preprocess(self, text: str) -> str:
        pass

class Postprocessor(ABC):
    @abstractmethod
    def postprocess(self, result: dict) -> dict:
        pass

# 具体实现
class TextCleaner(Preprocessor):
    def preprocess(self, text: str) -> str:
        # 清理HTML标签、特殊字符等
        import re
        text = re.sub(r'<[^>]+>', '', text)
        text = re.sub(r'[^\w\s]', '', text)
        return text.strip()

class EmotionDetector(SentimentProcessor):
    def process(self, text: str) -> dict:
        # 情感检测逻辑
        return {
            "emotions": [
                {"name": "joy", "intensity": 0.8},
                {"name": "excitement", "intensity": 0.6}
            ]
        }

class ConfidenceCalculator(Postprocessor):
    def postprocess(self, result: dict) -> dict:
        # 计算置信度
        emotions = result.get("emotions", [])
        confidence = sum(e["intensity"] for e in emotions) / len(emotions) if emotions else 0
        result["confidence"] = confidence
        return result

# 可扩展的处理管道
class SentimentPipeline:
    def __init__(self):
        self.preprocessors: List[Preprocessor] = []
        self.processors: List[SentimentProcessor] = []
        self.postprocessors: List[Postprocessor] = []
    
    def add_preprocessor(self, processor: Preprocessor):
        self.preprocessors.append(processor)
    
    def add_processor(self, processor: SentimentProcessor):
        self.processors.append(processor)
    
    def add_postprocessor(self, processor: Postprocessor):
        self.postprocessors.append(processor)
    
    def process(self, text: str) -> dict:
        # 预处理
        for preprocessor in self.preprocessors:
            text = preprocessor.preprocess(text)
        
        # 主处理
        result = {}
        for processor in self.processors:
            result.update(processor.process(text))
        
        # 后处理
        for postprocessor in self.postprocessors:
            result = postprocessor.postprocess(result)
        
        return result

# 使用示例 - 可以轻松扩展
pipeline = SentimentPipeline()
pipeline.add_preprocessor(TextCleaner())
pipeline.add_processor(EmotionDetector())
pipeline.add_postprocessor(ConfidenceCalculator())

# 扩展新的处理器而不修改现有代码
class SentimentClassifier(SentimentProcessor):
    def process(self, text: str) -> dict:
        # 新的情感分类逻辑
        positive_words = ["开心", "快乐", "高兴"]
        negative_words = ["难过", "伤心", "愤怒"]
        
        positive_count = sum(1 for word in positive_words if word in text)
        negative_count = sum(1 for word in negative_words if word in text)
        
        if positive_count > negative_count:
            sentiment = "positive"
        elif negative_count > positive_count:
            sentiment = "negative"
        else:
            sentiment = "neutral"
        
        return {"sentiment": sentiment}

# 添加新处理器
pipeline.add_processor(SentimentClassifier())
```

## 案例4：里氏替换原则的验证

```python
# 基类
class DataSource(ABC):
    @abstractmethod
    def connect(self) -> bool:
        pass
    
    @abstractmethod
    def query(self, sql: str) -> List[dict]:
        pass
    
    @abstractmethod
    def close(self) -> None:
        pass

# 子类1 - SQLite实现
class SQLiteDataSource(DataSource):
    def __init__(self, db_path: str):
        self.db_path = db_path
        self.connection = None
    
    def connect(self) -> bool:
        try:
            import sqlite3
            self.connection = sqlite3.connect(self.db_path)
            return True
        except Exception:
            return False
    
    def query(self, sql: str) -> List[dict]:
        cursor = self.connection.cursor()
        cursor.execute(sql)
        columns = [description[0] for description in cursor.description]
        return [dict(zip(columns, row)) for row in cursor.fetchall()]
    
    def close(self) -> None:
        if self.connection:
            self.connection.close()

# 子类2 - MySQL实现
class MySQLDataSource(DataSource):
    def __init__(self, host: str, user: str, password: str, database: str):
        self.host = host
        self.user = user
        self.password = password
        self.database = database
        self.connection = None
    
    def connect(self) -> bool:
        try:
            import pymysql
            self.connection = pymysql.connect(
                host=self.host,
                user=self.user,
                password=self.password,
                database=self.database
            )
            return True
        except Exception:
            return False
    
    def query(self, sql: str) -> List[dict]:
        cursor = self.connection.cursor(pymysql.cursors.DictCursor)
        cursor.execute(sql)
        return cursor.fetchall()
    
    def close(self) -> None:
        if self.connection:
            self.connection.close()

# 客户端代码 - 可以使用任何子类替换基类
class DataManager:
    def __init__(self, data_source: DataSource):
        self.data_source = data_source
    
    def get_sentiment_records(self, user_id: str) -> List[dict]:
        if not self.data_source.connect():
            return []
        
        try:
            sql = f"SELECT * FROM sentiment_records WHERE user_id = '{user_id}'"
            return self.data_source.query(sql)
        finally:
            self.data_source.close()

# 里氏替换验证
def test_liskov_substitution():
    # SQLite版本
    sqlite_source = SQLiteDataSource("sentiment.db")
    sqlite_manager = DataManager(sqlite_source)
    sqlite_results = sqlite_manager.get_sentiment_records("user123")
    
    # MySQL版本 - 完全可以替换SQLite版本
    mysql_source = MySQLDataSource("localhost", "root", "password", "sentiment_db")
    mysql_manager = DataManager(mysql_source)
    mysql_results = mysql_manager.get_sentiment_records("user123")
    
    # 客户端代码不需要改变，这就是里氏替换原则
    assert isinstance(sqlite_results, list)
    assert isinstance(mysql_results, list)
```

## 案例5：接口隔离的实际应用

```python
# 错误的设计 - 胖接口
class UserService(ABC):
    @abstractmethod
    def create_user(self, user_data: dict) -> dict:
        pass
    
    @abstractmethod
    def authenticate_user(self, username: str, password: str) -> bool:
        pass
    
    @abstractmethod
    def update_user_profile(self, user_id: str, profile: dict) -> dict:
        pass
    
    @abstractmethod
    def delete_user(self, user_id: str) -> bool:
        pass
    
    @abstractmethod
    def get_user_sentiment_history(self, user_id: str) -> List[dict]:
        pass

# 正确的设计 - 接口隔离
class UserManagement(ABC):
    """用户管理接口"""
    @abstractmethod
    def create_user(self, user_data: dict) -> dict:
        pass
    
    @abstractmethod
    def update_user_profile(self, user_id: str, profile: dict) -> dict:
        pass
    
    @abstractmethod
    def delete_user(self, user_id: str) -> bool:
        pass

class Authentication(ABC):
    """认证接口"""
    @abstractmethod
    def authenticate_user(self, username: str, password: str) -> bool:
        pass
    
    @abstractmethod
    def generate_token(self, user_id: str) -> str:
        pass

class DataQuery(ABC):
    """数据查询接口"""
    @abstractmethod
    def get_user_sentiment_history(self, user_id: str) -> List[dict]:
        pass
    
    @abstractmethod
    def get_user_statistics(self, user_id: str) -> dict:
        pass

# 客户端只依赖需要的接口
class SentimentAnalyzer:
    def __init__(self, data_query: DataQuery):
        # 只依赖数据查询接口，不需要用户管理或认证
        self.data_query = data_query
    
    def analyze_user_trends(self, user_id: str) -> dict:
        history = self.data_query.get_user_sentiment_history(user_id)
        # 分析趋势逻辑
        return {"trend": "improving"}

class UserAuthenticator:
    def __init__(self, authentication: Authentication):
        # 只依赖认证接口
        self.authentication = authentication
    
    def login(self, username: str, password: str) -> str:
        if self.authentication.authenticate_user(username, password):
            return self.authentication.generate_token(username)
        return ""
```

## 案例6：依赖倒置的完整实现

```python
# 抽象层
class NotificationService(ABC):
    @abstractmethod
    def send_notification(self, user_id: str, message: str) -> bool:
        pass

class CacheService(ABC):
    @abstractmethod
    def get(self, key: str) -> Optional[any]:
        pass
    
    @abstractmethod
    def set(self, key: str, value: any, ttl: int = 3600) -> bool:
        pass

class LoggingService(ABC):
    @abstractmethod
    def log_info(self, message: str) -> None:
        pass
    
    @abstractmethod
    def log_error(self, message: str, error: Exception) -> None:
        pass

# 具体实现
class EmailNotificationService(NotificationService):
    def send_notification(self, user_id: str, message: str) -> bool:
        # 发送邮件实现
        print(f"发送邮件给 {user_id}: {message}")
        return True

class RedisCacheService(CacheService):
    def __init__(self, redis_client):
        self.redis = redis_client
    
    def get(self, key: str) -> Optional[any]:
        return self.redis.get(key)
    
    def set(self, key: str, value: any, ttl: int = 3600) -> bool:
        return self.redis.setex(key, ttl, value)

class FileLoggingService(LoggingService):
    def __init__(self, log_file: str):
        self.log_file = log_file
    
    def log_info(self, message: str) -> None:
        with open(self.log_file, "a") as f:
            f.write(f"INFO: {message}\n")
    
    def log_error(self, message: str, error: Exception) -> None:
        with open(self.log_file, "a") as f:
            f.write(f"ERROR: {message} - {str(error)}\n")

# 高层业务逻辑 - 依赖抽象
class SentimentAnalysisOrchestrator:
    def __init__(
        self,
        notification_service: NotificationService,
        cache_service: CacheService,
        logging_service: LoggingService
    ):
        self.notification_service = notification_service
        self.cache_service = cache_service
        self.logging_service = logging_service
    
    def process_sentiment_with_alert(self, user_id: str, text: str) -> dict:
        try:
            self.logging_service.log_info(f"开始处理用户 {user_id} 的情感分析")
            
            # 检查缓存
            cache_key = f"sentiment:{hash(text)}"
            cached_result = self.cache_service.get(cache_key)
            if cached_result:
                self.logging_service.log_info("使用缓存结果")
                return cached_result
            
            # 执行分析
            result = self._analyze_sentiment(text)
            
            # 缓存结果
            self.cache_service.set(cache_key, result)
            
            # 如果是负面情感，发送通知
            if result.get("sentiment") == "negative" and result.get("intensity", 0) > 0.7:
                self.notification_service.send_notification(
                    user_id,
                    "检测到强烈的负面情绪，建议您寻求帮助"
                )
            
            self.logging_service.log_info(f"情感分析完成: {result.get('sentiment')}")
            return result
            
        except Exception as e:
            self.logging_service.log_error("情感分析失败", e)
            raise
    
    def _analyze_sentiment(self, text: str) -> dict:
        # 实际的分析逻辑
        return {"sentiment": "negative", "intensity": 0.8}

# 依赖注入容器
class DIContainer:
    def __init__(self):
        self._services = {}
    
    def register(self, interface_class, implementation_class):
        self._services[interface_class] = implementation_class
    
    def get(self, interface_class):
        implementation_class = self._services.get(interface_class)
        if not implementation_class:
            raise ValueError(f"未注册服务: {interface_class}")
        return implementation_class()
    
    def get_singleton(self, interface_class):
        if not hasattr(self, '_singletons'):
            self._singletons = {}
        
        if interface_class not in self._singletons:
            self._singletons[interface_class] = self.get(interface_class)
        
        return self._singletons[interface_class]

# 配置和启动
def setup_application():
    container = DIContainer()
    
    # 注册服务
    container.register(NotificationService, EmailNotificationService)
    container.register(CacheService, RedisCacheService)
    container.register(LoggingService, FileLoggingService)
    
    # 获取高层服务
    orchestrator = SentimentAnalysisOrchestrator(
        notification_service=container.get(NotificationService),
        cache_service=container.get(CacheService),
        logging_service=container.get(LoggingService)
    )
    
    return orchestrator
```

## 案例7：迪米特法则的严格实现

```python
# 违反迪米特法则的设计
class BadOrderService:
    def __init__(self):
        self.db = SessionLocal()
        self.payment_processor = PaymentProcessor()
        self.inventory = InventoryManager()
    
    def process_order(self, order_data: dict):
        # 直接操作多个对象的内部细节
        user = self.db.query(User).filter(User.id == order_data["user_id"]).first()
        
        # 直接访问user对象的内部属性
        if not user.is_active:
            return {"error": "用户未激活"}
        
        # 直接访问payment对象的内部方法
        payment = self.payment_processor.create_payment(
            amount=order_data["amount"],
            card_number=order_data["card_number"],
            expiry=order_data["expiry"],
            cvv=order_data["cvv"]
        )
        
        # 直接访问inventory对象的内部状态
        for item in order_data["items"]:
            product = self.inventory.get_product(item["product_id"])
            if product.stock < item["quantity"]:
                return {"error": "库存不足"}
        
        # ... 更多直接访问

# 遵循迪米特法则的设计
class UserStatusService:
    def is_user_active(self, user_id: str) -> bool:
        with SessionLocal() as db:
            user = db.query(User).filter(User.id == user_id).first()
            return user.is_active if user else False

class PaymentService:
    def process_payment(self, payment_data: dict) -> dict:
        processor = PaymentProcessor()
        return processor.create_payment(
            amount=payment_data["amount"],
            **payment_data["payment_method"]
        )

class InventoryService:
    def check_availability(self, items: List[dict]) -> bool:
        inventory = InventoryManager()
        for item in items:
            if not inventory.is_available(item["product_id"], item["quantity"]):
                return False
        return True

class OrderService:
    def __init__(self):
        self.user_service = UserStatusService()
        self.payment_service = PaymentService()
        self.inventory_service = InventoryService()
    
    def process_order(self, order_data: dict) -> dict:
        # 只与直接的服务交互，不关心内部实现
        
        # 检查用户状态
        if not self.user_service.is_user_active(order_data["user_id"]):
            return {"error": "用户未激活"}
        
        # 检查库存
        if not self.inventory_service.check_availability(order_data["items"]):
            return {"error": "库存不足"}
        
        # 处理支付
        payment_result = self.payment_service.process_payment({
            "amount": order_data["amount"],
            "payment_method": order_data["payment_method"]
        })
        
        if not payment_result["success"]:
            return {"error": "支付失败"}
        
        # 创建订单
        order_id = self._create_order(order_data)
        
        return {"success": True, "order_id": order_id}
    
    def _create_order(self, order_data: dict) -> str:
        # 私有方法，隐藏创建订单的细节
        with SessionLocal() as db:
            order = Order(**order_data)
            db.add(order)
            db.commit()
            return str(order.id)
```

## 重构检查清单

### 单一职责原则检查
- [ ] 每个类只有一个变化的原因？
- [ ] 类的方法是否都与同一个职责相关？
- [ ] 是否可以将类拆分为更小的类？

### 开闭原则检查
- [ ] 添加新功能时是否需要修改现有代码？
- [ ] 是否使用了抽象和多态来支持扩展？
- [ ] 配置和代码是否分离？

### 里氏替换原则检查
- [ ] 子类是否可以完全替换基类？
- [ ] 子类是否违反了基类的契约？
- [ ] 客户端代码是否依赖基类而不是具体实现？

### 接口隔离原则检查
- [ ] 接口是否过于庞大？
- [ ] 客户端是否被迫依赖不需要的方法？
- [ ] 是否可以拆分接口为更小的、专门的接口？

### 依赖倒置原则检查
- [ ] 高层模块是否依赖低层模块？
- [ ] 是否都依赖抽象而不是具体实现？
- [ ] 是否使用了依赖注入？

### 组合优于继承检查
- [ ] 是否过度使用继承？
- [ ] 是否可以用组合替代继承？
- [ ] 继承层次是否过深？

### 迪米特法则检查
- [ ] 对象是否知道太多其他对象的内部细节？
- [ ] 是否通过中间层来减少直接依赖？
- [ ] 方法调用链是否过长？

---

*这些补充示例展示了在实际项目中如何应用和重构代码以符合面向对象设计原则。*